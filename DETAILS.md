# Industry Simulation - Detailed Documentation

Complete reference for the Industry Simulation RL Environment.

---

## Table of Contents

1. [Real Company Data Pipeline](#1-real-company-data-pipeline) ⭐ NEW
2. [Environment Specification](#2-environment-specification)
3. [Multi-Action System](#3-multi-action-system)
4. [Product System & Supply Chain](#4-product-system--supply-chain)
5. [Logistic Cost System](#5-logistic-cost-system)
6. [Revenue Rate System](#6-revenue-rate-system)
7. [Death Threshold System](#7-death-threshold-system)
8. [Configuration System](#8-configuration-system)
9. [Module Structure](#9-module-structure)
10. [Training Guide](#10-training-guide)
11. [Visualization System](#11-visualization-system)
12. [Spatial Analysis](#12-spatial-analysis)
13. [API Reference](#13-api-reference)
14. [Best Practices](#14-best-practices)

---

## 1. Real Company Data Pipeline

### Overview

The simulation uses **real company data** from 927 companies in the automotive supply chain. Data is processed from Excel files containing Chinese company registration records.

### Company Data Fields (7 total)

| Field | Type | Description | Completeness |
|-------|------|-------------|--------------|
| **company_name** | string | Company legal name | 927/927 (100%) |
| **sector** | string | Industry sector classification | 927/927 (100%) |
| **company_size** | string | Size: large, medium, small, micro | 927/927 (100%) |
| **initial_capital** | float | Registered capital amount (CNY) | 927/927 (100%) |
| **establishment_date** | string | Founding date (成立日期) | 927/927 (100%) |
| **active** | boolean | Current status (true/false) | 927/927 (100%) |
| **death_date** | string/null | Closure date if inactive (注销日期) | 339/927 (36.6%) |

### Data Statistics

- **Total companies**: 927
- **Active companies**: 361 (38.9%)
- **Inactive companies**: 566 (61.1%)
- **Companies with death dates**: 339 (36.6% of all companies, 59.9% of inactive)

### Sector Distribution

| Sector | Count | Percentage |
|--------|-------|------------|
| Raw Materials | ~120 | 13% |
| Parts | ~280 | 30% |
| Electronics | ~180 | 19% |
| Battery/Motor | ~95 | 10% |
| OEM | ~140 | 15% |
| Service | ~90 | 10% |
| Other | ~22 | 3% |

### Data Processing Pipeline

#### Source Data

- **Format**: Excel (.xlsx)
- **Language**: Chinese (Simplified)
- **Origin**: Company registration records
- **Key columns**:
  - 成立日期 (Establishment Date)
  - 登记状态 (Registration Status) - Contains both status and optional death date

#### Processing Script

Located at `data/supply_chain.py`:

```python
import re
from typing import Tuple, Optional

def parse_registration_status(status: str) -> Tuple[bool, Optional[str]]:
    """
    Parse registration status into active boolean and optional death date.
    
    Examples:
        "存续" → (True, None)
        "在业" → (True, None)
        "注销（2017-06-16）" → (False, "2017-06-16")
        "吊销（2020-03-15）" → (False, "2020-03-15")
    
    Args:
        status: Registration status string from Excel
    
    Returns:
        Tuple of (is_active, death_date)
    """
    if not isinstance(status, str):
        return True, None  # Default to active if missing/invalid
    
    status_str = status.strip()
    
    # Active status patterns
    active_patterns = ['存续', '在业', '开业', '正常', '营业']
    if any(pattern in status_str for pattern in active_patterns):
        return True, None
    
    # Extract death date from pattern like "注销（2017-06-16）"
    date_match = re.search(r'（(\d{4}-\d{2}-\d{2})）', status_str)
    if date_match:
        return False, date_match.group(1)
    
    # Inactive without specific date
    inactive_patterns = ['注销', '吊销', '迁出', '停业']
    if any(pattern in status_str for pattern in inactive_patterns):
        return False, None
    
    # Default to active if unclear
    return True, None
```

#### Data Transformation Timeline

1. **Initial**: Excel with company_name, sector, size, capital, establishment_date, registration_status
2. **Transformation 1** (Oct 2024): Added establishment_date and registration_status fields from Excel
3. **Transformation 2** (Oct 2024): Converted registration_status to:
   - `active` (boolean): True if company still operating
   - `death_date` (optional string): Date extracted from status if company closed

#### Output Files

Generated by running `cd data && uv run python supply_chain.py`:

1. **company_classification.json**

   ```json
   [
     {
       "company_name": "某某汽车配件有限公司",
       "sector": "Parts",
       "company_size": "medium",
       "initial_capital": 5000000.0,
       "establishment_date": "2010-03-15",
       "active": false,
       "death_date": "2017-06-16"
     },
     ...
   ]
   ```

2. **company_classification.csv**

   ```csv
   company_name,sector,company_size,initial_capital,establishment_date,active,death_date
   某某汽车配件有限公司,Parts,medium,5000000.0,2010-03-15,false,2017-06-16
   ...
   ```

### Integration with Simulation

The processed company data can be used to:

1. **Initialize realistic company distributions** - Use actual sector counts and sizes
2. **Set realistic capital levels** - Use actual registered capital amounts
3. **Model company lifespans** - Analyze survival rates by sector and establishment date
4. **Calibrate death threshold** - Based on actual company failure rates
5. **Study temporal dynamics** - Analyze how establishment date correlates with survival

### Data Validation

Validation checks performed in `supply_chain.py`:

- ✅ All 927 companies have complete core fields (name, sector, size, capital, establishment_date, active)
- ✅ Active status properly parsed (361 active, 566 inactive)
- ✅ Death dates extracted where available (339 companies)
- ✅ Date formats validated (YYYY-MM-DD)
- ✅ Sector assignments match 7-sector taxonomy
- ✅ Capital amounts are non-negative floats

### Usage Example

```python
import json

# Load company data
with open('data/company_classification.json', 'r', encoding='utf-8') as f:
    companies = json.load(f)

# Analyze active companies by sector
from collections import Counter
active_by_sector = Counter(
    c['sector'] for c in companies if c['active']
)
print("Active companies by sector:")
for sector, count in active_by_sector.most_common():
    print(f"  {sector}: {count}")

# Find companies that closed in specific year
closed_2017 = [
    c for c in companies 
    if c['death_date'] and c['death_date'].startswith('2017')
]
print(f"\nCompanies closed in 2017: {len(closed_2017)}")
```

### Future Enhancements

Potential additions to the data pipeline:

- **Geographic coordinates** - Real company locations for spatial initialization
- **Revenue data** - Historical revenue for calibrating revenue rate system
- **Employee counts** - For more nuanced company size classification
- **Ownership structure** - Parent-subsidiary relationships
- **Investment history** - Actual capital injection events

### References

- **Data source**: `data/data.xlsx` (Chinese company registration database)
- **Processing script**: `data/supply_chain.py`
- **Output files**: `data/company_classification.{json,csv}`
- **Documentation**: `data/README.md` (comprehensive 783-line guide)

---

## 2. Environment Specification

### Overview

The Industry Simulation is a Gymnasium-compatible RL environment modeling economic dynamics with:

- Multiple companies across 7 industry sectors (automotive supply chain)
- Spatial positioning with (x, y) coordinates
- 5-tier supply chain relationships between sectors
- Distance-based logistic costs (inverse square law)
- Dynamic company creation and capital investment

### Sector Definitions

The environment uses a **7-sector automotive supply chain** organized into 5 tiers:

| ID | Sector | Tier | Suppliers | Consumers |
|----|--------|------|-----------|-----------|
| 0 | Raw Materials | 0 | None | Parts, Electronics, Battery/Motor |
| 1 | Parts | 1 | Raw Materials | OEM |
| 2 | Electronics | 1 | Raw Materials | OEM |
| 3 | Battery/Motor | 1 | Raw Materials | OEM |
| 4 | OEM (Assembly) | 2 | Parts, Electronics, Battery/Motor | Service |
| 5 | Service | 3 | OEM | None |
| 6 | Other | 4 | None | None |

**Supply Chain Flow:**

```
Tier 0: Raw Materials (produces from scratch)
   ↓
Tier 1: Parts, Electronics, Battery/Motor (buy from Raw)
   ↓
Tier 2: OEM (buys from all Tier 1 sectors, assembles vehicles)
   ↓
Tier 3: Service (buys from OEM, serves end customers)

Tier 4: Other (isolated, no supply chain connections)
```

## Action Space

Dictionary space with operation selector:

```python
{
    "op": Discrete(2),  # 0 = invest, 1 = create
    "invest": {
        "firm_id": Discrete(max_company),
        "amount": Box(low=0.0, high=1_000_000.0, shape=(1,))
    },
    "create": {
        "initial_capital": Box(low=1000.0, high=1_000_000.0, shape=(1,)),
        "sector": Discrete(num_sectors),
        "location": Box(low=0.0, high=size, shape=(2,))
    }
}
```

**Operation 0: Invest**

- Increases capital of existing company
- Reward: `investment_amount * 0.01` (configurable)
- Penalty: `-10.0` for invalid firm_id

**Operation 1: Create**

- Creates new company in specified sector and location
- Reward: `50.0` (configurable)
- Penalty: `-20.0` for invalid creation (capacity full or invalid location)

## Observation Space

Dictionary with aggregate metrics:

```python
{
    "num_firms": Discrete(max_company + 1),
    "total_capital": Box(low=0.0, high=inf, shape=(1,)),
    "sector_counts": Box(low=0, high=max_company, shape=(num_sectors,)),
    "avg_revenue": Box(low=0.0, high=inf, shape=(1,))
}
```

**Design Rationale**: Aggregate observations ensure scalability to large numbers of companies without exploding observation dimensionality.

## Reward Function

Total reward combines:

```python
reward = action_reward + profit_component

# Action reward
if op == 0:  # Invest
    action_reward = amount * investment_multiplier  # default: 0.01
elif op == 1:  # Create
    action_reward = creation_reward  # default: 50.0

# Profit component
profit_component = total_profit * profit_multiplier  # default: 0.001
```

All multipliers configurable in `config.json`.

## Episode Termination

- **Terminated**: Currently always False (continuous environment)
- **Truncated**: After `max_episode_steps` (default: 1000)

## Company Mechanics

Each company has:

- **Capital**: Current financial value
- **Sector**: Industry sector ID (0-9)
- **Location**: (x, y) coordinates on map
- **Operating costs**: `op_cost_rate * capital` per step (default: 5%)
- **Logistic costs**: Distance-based transportation costs
- **Revenue**: Income from supply chain trades

### Company Step Process

Each environment step:

1. **Supply chain simulation** runs (companies trade)
2. **Logistic costs** calculated based on distance
3. **Company step** executes:

   ```python
   op_cost = op_cost_rate * capital
   total_cost = op_cost + logistic_cost
   profit = revenue - total_cost
   capital += profit
   ```

4. **Costs and revenues reset** for next step
5. **Death check**: Companies with `capital < death_threshold` are removed

### Company Death Mechanism

Companies are removed from the simulation if their capital falls below the `death_threshold` hyperparameter:

```python
# After all companies execute their step
for company in companies:
    if company.capital < death_threshold:
        remove(company)  # Bankruptcy/death
```

**Use Cases**:

- **death_threshold = 0.0** (default): No deaths, companies can have negative capital
- **death_threshold > 0**: Realistic bankruptcy mechanism
- **death_threshold = 10000**: Moderate pressure, weak companies eliminated
- **death_threshold = 50000**: High pressure, only strong companies survive

**Strategic Impact**:

- Creates natural selection in the economy
- Encourages agents to avoid risky decisions
- Models realistic business failure
- Increases environment dynamics and turnover

---

## 3. Multi-Action System

### Overview

The Industry Simulation environment supports **multiple actions per step**. The agent can choose to perform between 0 and `max_actions_per_step` actions in a single environment step, enabling much more efficient training and strategic gameplay.

## Action Space Structure

The action space uses a nested Dictionary structure:

```python
action_space = gym.spaces.Dict({
    "num_actions": gym.spaces.Discrete(max_actions_per_step + 1),  # 0 to max_actions_per_step
    "actions": gym.spaces.Tuple([
        gym.spaces.Dict({
            "op": gym.spaces.Discrete(2),  # 0 = invest, 1 = create
            "invest": gym.spaces.Dict({
                "firm_id": gym.spaces.Discrete(max_company),
                "amount": gym.spaces.Box(low=0.0, high=1_000_000.0, shape=(1,), dtype=np.float32),
            }),
            "create": gym.spaces.Dict({
                "initial_capital": gym.spaces.Box(low=1000.0, high=1_000_000.0, shape=(1,), dtype=np.float32),
                "sector": gym.spaces.Discrete(num_sectors),
                "location": gym.spaces.Box(low=0.0, high=size, shape=(2,), dtype=np.float32),
            }),
        })
        for _ in range(max_actions_per_step)
    ])
})
```

## Action Format

Actions are provided as:

```python
action = {
    "num_actions": 3,  # Number of actions to execute (0 to max_actions_per_step)
    "actions": [
        {  # Action 1: Invest in company 0
            "op": 0,
            "invest": {"firm_id": 0, "amount": [1000.0]},
            "create": {"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]}
        },
        {  # Action 2: Create new company
            "op": 1,
            "invest": {"firm_id": 0, "amount": [1000.0]},
            "create": {"sector": 2, "initial_capital": [25000.0], "location": [30.0, 40.0]}
        },
        {  # Action 3: Invest in company 1
            "op": 0,
            "invest": {"firm_id": 1, "amount": [2000.0]},
            "create": {"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]}
        },
        # ... up to max_actions_per_step total actions
    ]
}
```

**Important**: The `actions` list must always contain `max_actions_per_step` action dicts, but only the first `num_actions` will be executed. The `op` field determines which action to use (invest or create).

## Configuration

### In config.json

```json
{
  "environment": {
    "max_actions_per_step": 10
  }
}
```

### In Code

```python
from config import Config
from env import IndustryEnv

config = Config()
config.environment.max_actions_per_step = 10

env = IndustryEnv(config.environment)
```

## Info Dictionary

The `info` dictionary returned by `step()` includes detailed action tracking:

```python
info = {
    "action_results": [  # List of individual action results
        {
            "action_idx": 0,
            "result": "valid_invest",
            "investment_amount": 1000.0
        },
        {
            "action_idx": 1,
            "result": "valid_create",
            "investment_amount": 0.0
        },
        # ... one entry per executed action
    ],
    "num_actions": 3,            # Number of actions requested
    "num_valid_actions": 3,      # Number of successful actions
    "num_invalid_actions": 0,    # Number of failed actions
    "investment_amount": 3000.0, # Total investment across all actions
    "total_profit": -15234.56,   # Total profit from all companies
    "total_logistic_cost": 234.56,
    "num_firms": 8,
    "num_deaths": 0
}
```

## Reward Calculation

Rewards accumulate across all actions:

```python
# Example: 2 valid invests + 1 valid create + 1 invalid action
reward = (1000 * 0.01) + (2000 * 0.01) + 50.0 + (-20.0) + (total_profit * 0.001)
       = 10.0 + 20.0 + 50.0 - 20.0 + profit_component
       = 60.0 + profit_component
```

**Reward Components**:

- **Investment**: `amount × investment_multiplier` (default: 0.01)
- **Creation**: `creation_reward` (default: 50.0)
- **Invalid action**: `invalid_action_penalty` (default: -20.0)
- **Profit**: `total_profit × profit_multiplier` (default: 0.001)

## Usage Examples

### Example 1: Zero Actions (Do Nothing)

```python
action = {
    "num_actions": 0,
    "actions": [...]  # Still need max_actions_per_step actions, but won't execute
}
obs, reward, terminated, truncated, info = env.step(action)
# reward = 0.0 + (total_profit * profit_multiplier)
```

### Example 2: Single Action

```python
from tests import create_single_action

action = create_single_action(
    op=0,  # Invest
    invest_dict={"firm_id": 0, "amount": [5000.0]},
    create_dict={"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]},
    max_actions=env.max_actions_per_step
)

obs, reward, terminated, truncated, info = env.step(action)
# reward = (5000 * 0.01) + profit_component = 50.0 + profit_component
```

### Example 3: Multiple Actions

```python
action = {
    "num_actions": 5,
    "actions": [
        {"op": 0, "invest": {"firm_id": 0, "amount": [1000.0]}, ...},
        {"op": 0, "invest": {"firm_id": 1, "amount": [1500.0]}, ...},
        {"op": 1, "create": {"sector": 2, "initial_capital": [30000.0], "location": [25.0, 75.0]}, ...},
        {"op": 0, "invest": {"firm_id": 2, "amount": [800.0]}, ...},
        {"op": 1, "create": {"sector": 5, "initial_capital": [40000.0], "location": [80.0, 20.0]}, ...},
        # ... fill remaining slots with dummy actions
    ]
}

obs, reward, terminated, truncated, info = env.step(action)
```

## Test Helper Functions

The `tests/__init__.py` module provides helper functions for easy action creation:

```python
from tests import create_single_action, create_multi_action, create_dummy_action

# Create single invest action
action = create_single_action(
    op=0,
    invest_dict={"firm_id": 0, "amount": [1000.0]},
    create_dict={"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]},
    max_actions=10
)

# Create multiple actions
actions_list = [
    (0, {"firm_id": 0, "amount": [1000.0]}, None),  # Invest
    (1, None, {"sector": 2, "initial_capital": [20000.0], "location": [30.0, 40.0]}),  # Create
]
action = create_multi_action(actions_list, max_actions=10)

# Create dummy/placeholder action
dummy = create_dummy_action()
```

## Benefits

1. **Efficiency**: 3-5x faster than single-action equivalent (supply chain runs once per step)
2. **Flexibility**: Agent chooses optimal action count per situation
3. **Strategy**: Balance between investments and creations in a single decision
4. **Realistic**: Models real-world batch decision making
5. **Scalable**: Handles 0 to max_actions_per_step seamlessly

## Performance Considerations

- Each action is validated and executed independently
- Supply chain simulation runs **once per step** (not per action)
- Company operations run **once per step** (not per action)
- Death checks run **once per step** (not per action)

**Result**: Taking multiple actions per step is much more efficient than taking multiple steps!

## Migration from Single Action

**⚠️ Breaking Change**: The action format changed from single to multi-action.

**Old Format** (No Longer Supported):

```python
action = {
    "op": 0,
    "invest": {"firm_id": 0, "amount": [1000.0]},
    "create": {"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]}
}
```

**New Format** (Required):

```python
action = {
    "num_actions": 1,
    "actions": [
        {
            "op": 0,
            "invest": {"firm_id": 0, "amount": [1000.0]},
            "create": {"sector": 0, "initial_capital": [10000.0], "location": [50.0, 50.0]}
        },
        # ... must have max_actions_per_step total actions
    ]
}
```

Use the `create_single_action()` helper to easily migrate existing code.

## Testing

Run the comprehensive test suite:

```bash
python tests/test_multi_action.py
```

Tests cover:

- Zero actions
- Single action (invest/create)
- Multiple actions
- Maximum actions
- Mixed valid/invalid actions
- Action results tracking
- Reward accumulation
- Configuration respect

---

## 4. Product System & Supply Chain

### Overview

The product system adds a comprehensive upstream-downstream supply chain mechanism where companies produce, buy, and sell actual products based on their position in the supply chain tiers.

## Supply Chain Tiers

The environment uses **7 sectors** organized into **5 tiers** based on the automotive supply chain:

| Tier | Sector ID | Name | Role |
|------|-----------|------|------|
| **0** (Root) | 0 | Raw Materials | Produces from scratch |
| **1** | 1 | Parts | Buys from Raw |
| **1** | 2 | Electronics | Buys from Raw |
| **1** | 3 | Battery/Motor | Buys from Raw |
| **2** | 4 | OEM (Assembly) | Buys from Tier 1 |
| **3** | 5 | Service | Buys from OEM |
| **4** (Isolated) | 6 | Other | No connections |

### Supply Chain Flow

```
Tier 0: Raw Materials (produces from scratch)
   ↓ supplies to
Tier 1: Parts, Electronics, Battery/Motor (buy from Raw)
   ↓ supplies to
Tier 2: OEM (buys from Parts, Electronics, Battery/Motor)
   ↓ supplies to
Tier 3: Service (buys from OEM)

Tier 4: Other (standalone, no connections)
```

## Dynamic Tier Calculation

Tiers are **automatically calculated** from sector relationships using topological sorting:

```python
def calculate_sector_tiers(sectors: list[Sector]) -> dict[int, int]:
    """
    Calculate supply chain tiers automatically from sector relationships.
    
    Algorithm:
    1. Separate connected vs isolated sectors
    2. Assign Tier 0 to root nodes (no suppliers, has consumers)
    3. Iteratively assign tiers: tier = max(supplier_tiers) + 1
    4. Assign isolated sectors to sequential tiers after highest connected
    """
    # ... implementation ...
```

**Benefits**:

- Automatic adaptation to changes in `sector_relations`
- No manual tier assignment needed
- Handles edge cases (isolated, leaf, root sectors)
- Guaranteed correctness via topological sort

See `demo_tier_calculation.py` for visualization.

## Company Attributes

### Product-Related Attributes

Each company has:

- **`product_inventory`**: Current stock of products (float)
- **`tier`**: Supply chain tier (0 = most upstream)
- **`suppliers`**: List of upstream companies this company buys from
- **`customers`**: List of downstream companies that buy from this company
- **`production_capacity_ratio`**: Max production = capital × ratio (default: 0.1)
- **`purchase_budget_ratio`**: Max purchase = capital × ratio (default: 0.2)

### Per-Step Tracking

- **`products_produced_this_step`**: Amount produced
- **`products_sold_this_step`**: Amount sold
- **`products_purchased_this_step`**: Amount purchased

## Supply Chain Process

Each simulation step executes in this order:

1. **Build Supply Chain Network** (when companies created/removed)
   - Lower tier companies → suppliers to higher tier
   - Higher tier companies → customers of lower tier

2. **Tier 0 Production**
   - Most upstream companies produce products from scratch
   - Production = `capital × production_capacity_ratio`

3. **Purchase & Sales** (Tier 1 to Max)
   - For each tier (bottom-up):
     - Calculate customer demand
     - Purchase from suppliers (limited by budget)
     - Fulfill customer orders from inventory
     - Pay logistic costs based on distance

### Production (Tier 0 Only)

```python
production_amount = company.capital * production_capacity_ratio
company.product_inventory += production_amount
company.products_produced_this_step = production_amount
```

**Example**: Company with $50,000 capital and ratio 0.1

- Produces: 50,000 × 0.1 = 5,000 units per step

### Purchasing (Tier 1+)

```python
max_budget = company.capital * purchase_budget_ratio
actual_purchase = min(desired_amount, max_budget, supplier_inventory)

# For each supplier:
company.capital -= purchase_amount  # Pay supplier
company.product_inventory += purchase_amount  # Receive products
supplier.capital += purchase_amount  # Supplier receives payment
supplier.product_inventory -= purchase_amount  # Supplier ships products
company.add_logistic_cost(...)  # Distance-based shipping cost
```

**Example**: Company with $40,000 capital and ratio 0.2

- Max purchase budget: 40,000 × 0.2 = $8,000 per step
- If 2 suppliers: $4,000 allocated to each

### Selling

```python
fulfilled_amount = min(requested_amount, inventory)
company.product_inventory -= fulfilled_amount
company.products_sold_this_step += fulfilled_amount
# Payment handled in customer's purchase process
```

### Constraints

1. **Production**: Only Tier 0 produces from scratch
2. **Purchase**: `amount ≤ capital × purchase_budget_ratio`
3. **Sales**: `amount ≤ current_inventory`
4. **Capital**: Must have positive capital to purchase

## Configuration

```json
{
  "environment": {
    "enable_products": true,
    "production_capacity_ratio": 0.1,
    "purchase_budget_ratio": 0.2
  }
}
```

## Company Methods

### Product-Related Methods

```python
# Get limits
company.get_max_production() -> float
company.get_max_purchase_budget() -> float

# Operations
company.produce_products() -> float                    # Tier 0 only
company.receive_order(amount: float) -> float          # Fulfill from inventory
company.purchase_from_suppliers(orders: float) -> float  # Buy from suppliers
company.reset_step_counters()                          # Reset per-step tracking
```

## Info Dictionary Updates

```python
info = {
    # ... existing fields ...
    "total_inventory": float,    # Sum of all inventories
    "total_produced": float,     # Sum of production this step
    "total_sold": float,        # Sum of sales this step
    "total_purchased": float,   # Sum of purchases this step
}
```

## Backward Compatibility

The product system is **fully backward compatible**:

```python
# Disable products to use original generic supply chain
config.environment.enable_products = False

# Falls back to _simulate_generic_supply_chain()
```

All existing code continues to work.

## Testing

Run tests:

```bash
python tests/test_product_system.py
```

Run demo:

```bash
python demos/demo_product_system.py
python demos/demo_tier_calculation.py
```

---

## 5. Logistic Cost System

### Overview

Distance-based transportation costs model real economic effects where companies benefit from clustering near supply chain partners.

## Mathematical Model

### Inverse Square Law

```
cost = k × volume / distance²
```

Where:

- **k** = `logistic_cost_rate` (hyperparameter, default: 100.0)
- **volume** = trade volume between companies
- **distance** = Euclidean distance: `√((x₁-x₂)² + (y₁-y₂)²)`

### Why Inverse Square Law?

1. **Economies of Scale**: Longer routes enable bulk transportation
2. **Network Effects**: Distant companies use efficient transport modes
3. **Route Optimization**: Long distances allow better planning
4. **Game Dynamics**: Creates interesting strategic trade-offs

### Cost Scaling

| Distance | Relative Cost | Reduction |
|----------|---------------|-----------|
| 1.0 | 100% | - |
| 2.0 | 25% | 75% |
| 5.0 | 4% | 84% |
| 10.0 | 1% | 90% |
| 50.0 | 0.04% | 99.96% |

**Key Property**: Doubling distance reduces cost to 25% of original.

## Implementation

### Company Class

```python
class Company:
    def __init__(self, capital, sector_id, location, 
                 op_cost_rate=0.05, logistic_cost_rate=100.0):
        self.logistic_cost_rate = logistic_cost_rate
        self.logistic_cost = 0.0  # Accumulated per step
        
    def calculate_logistic_cost_to(self, other, trade_volume=1.0):
        distance = max(self.distance_to(other), 0.1)  # Min distance
        return self.logistic_cost_rate * trade_volume / (distance ** 2)
        
    def add_logistic_cost(self, cost):
        self.logistic_cost += cost
```

### Environment Supply Chain

```python
def _simulate_supply_chain(self):
    for company in self.companies:
        sector = sector_relations[company.sector_id]
        
        # Find trading partners based on sector relationships
        customers = [c for c in self.companies 
                    if sector.name in sector_relations[c.sector_id].suppliers]
        
        if customers:
            trade_volume = company.capital * 0.01 / len(customers)
            
            for customer in customers:
                # Calculate and apply logistic cost
                cost = company.calculate_logistic_cost_to(customer, trade_volume)
                company.add_logistic_cost(cost)
                company.add_revenue(trade_volume)
```

Called automatically in `env.step()` before company operations.

## Hyperparameter Tuning

### Effect of `logistic_cost_rate`

| Rate | Effect | Clustering | Use Case |
|------|--------|-----------|----------|
| **0** | No costs | None | Ablation baseline |
| **10** | Weak | Minimal | Testing |
| **100** | Moderate | Noticeable | **Default** |
| **500** | Strong | Significant | Strategic play |
| **1000+** | Very strong | Forced | Extreme clustering |

### Example Costs

With rate=100, volume=1000:

| Distance | Cost | Cost/Unit | Net Revenue |
|----------|------|-----------|-------------|
| 1.0 | $100,000 | $100.00 | -$99,000 |
| 5.0 | $4,000 | $4.00 | -$3,000 |
| 10.0 | $1,000 | $1.00 | $0 |
| 20.0 | $250 | $0.25 | $750 |
| 50.0 | $40 | $0.04 | $960 |

**Breakeven**: ~10 units for this example.

## Strategic Implications

### For RL Agents

1. **Location Selection**: Placing companies near supply chain partners reduces costs
2. **Sector Clustering**: Related sectors benefit from proximity
3. **Trade-offs**: Balance accessibility vs. competition for space
4. **Emergent Behavior**: Industrial districts form naturally

### Observed Patterns

From testing:

- **Dispersed layout**: Higher total costs, lower profits
- **Clustered layout**: 75%+ cost reduction, higher profits
- **Hub formation**: Central companies serve multiple partners
- **Sector grouping**: Related industries co-locate

## Testing

Run comprehensive tests:

```bash
python test_logistic_cost.py
```

Demonstrates:

- Inverse square law calculation
- Cost reduction with distance
- Impact on profitability
- Clustering benefits

Visual demonstration:

```bash
python demo_logistic_cost.py
```

Generates:

- Cost vs distance plots
- Clustering comparison visualizations
- Interactive cost calculator

---

## 6. Revenue Rate System

### Overview

The `revenue_rate` hyperparameter controls how efficiently companies convert trade orders into revenue. This provides a simple but powerful way to model profit margins across different industries.

## Mathematical Model

### Formula

```
revenue = revenue_rate × order_amount
```

Where:

- **revenue_rate** = Conversion efficiency (hyperparameter, default: 1.0)
- **order_amount** = Trade volume from supply chain transactions
- **revenue** = Actual revenue added to company

### Economic Interpretation

| Revenue Rate | Meaning | Industry Examples |
|--------------|---------|-------------------|
| **< 1.0** | Low margins | Retail, commodities, agriculture |
| **= 1.0** | Standard margins | Manufacturing, services |
| **> 1.0** | High margins | Technology, finance, luxury goods |

## Implementation

### Company Class

```python
class Company:
    def __init__(self, capital, sector_id, location, 
                 op_cost_rate=0.05, logistic_cost_rate=100.0, revenue_rate=1.0):
        self.revenue_rate = revenue_rate
        self.revenue = 0.0
        self.orders = 0
        
    def add_revenue(self, order_amount: float):
        """Add revenue from sales/orders using revenue_rate * order_amount."""
        self.revenue += self.revenue_rate * order_amount
        self.orders += 1
```

### Environment Supply Chain

```python
def _simulate_supply_chain(self):
    for company in self.companies:
        # ... find trading partners ...
        
        for customer in customers:
            trade_volume = company.capital * 0.01 / len(customers)
            
            # Revenue scales with revenue_rate
            company.add_revenue(trade_volume)  # revenue = rate × trade_volume
```

## Use Cases

### 1. Industry-Specific Margins

Model different profit margins by sector:

```python
# High-margin tech sector
env_tech = IndustryEnv(revenue_rate=2.0)

# Low-margin retail sector  
env_retail = IndustryEnv(revenue_rate=0.5)
```

### 2. Economic Scenarios

Test different market conditions:

```python
# Boom economy (high margins)
env_boom = IndustryEnv(revenue_rate=1.5)

# Recession (compressed margins)
env_recession = IndustryEnv(revenue_rate=0.7)
```

### 3. Training Difficulty

Adjust challenge for RL agents:

```python
# Easier (high revenues)
env_easy = IndustryEnv(revenue_rate=2.0)

# Harder (low revenues, must optimize)
env_hard = IndustryEnv(revenue_rate=0.5)
```

## Hyperparameter Tuning

### Effect of revenue_rate

| Rate | Effect on Companies | Agent Strategy |
|------|---------------------|----------------|
| **0.25** | Very low profits | Must maximize orders, minimize costs |
| **0.5** | Low profits | Efficiency critical |
| **1.0** | **Default** | Balanced |
| **1.5** | High profits | Can afford experimentation |
| **2.0** | Very high profits | Aggressive expansion viable |

### Example Scenarios

With trade volume = $1000:

| Rate | Revenue | Profit* | Viability |
|------|---------|---------|-----------|
| 0.25 | $250 | -$750 | Unprofitable |
| 0.5 | $500 | -$500 | Barely viable |
| 1.0 | $1,000 | $0 | Breakeven |
| 1.5 | $1,500 | $500 | Profitable |
| 2.0 | $2,000 | $1,000 | Very profitable |

*Assuming $1,000 in costs (operating + logistic)

## Strategic Implications

### For RL Agents

1. **Low revenue_rate** (< 1.0):
   - Must carefully manage costs
   - Location optimization critical (minimize logistic costs)
   - High order volume needed for profitability
   - Clustering near partners essential

2. **High revenue_rate** (> 1.0):
   - More room for exploration
   - Can afford suboptimal locations
   - Fewer orders needed for profit
   - Expansion encouraged

### Interaction with Logistic Costs

Revenue rate and logistic costs create interesting trade-offs:

```python
# High margins, high costs: Remote high-value industries
env1 = IndustryEnv(revenue_rate=2.0, logistic_cost_rate=500.0)

# Low margins, low costs: Local commodity markets
env2 = IndustryEnv(revenue_rate=0.5, logistic_cost_rate=10.0)
```

## Configuration

### In config.json

```json
{
  "supply_chain": {
    "trade_volume_fraction": 0.01,
    "revenue_rate": 1.0,         // ← Adjust this
    "enable_supply_chain": true
  }
}
```

### In Code

```python
from config import load_config

config = load_config("config.json")
env = IndustryEnv(
    revenue_rate=config.supply_chain.revenue_rate
)
```

## Testing

Run comprehensive tests:

```bash
python test_revenue_rate.py
```

Demonstrates:

- Formula verification (revenue = rate × order)
- Multiple revenue rates (0.5, 1.0, 1.5, 2.0)
- Order accumulation
- Revenue scaling

Visual demonstration:

```bash
python demo_revenue_rate.py
```

Shows:

- Three scenarios (rate = 0.5, 1.0, 2.0)
- Impact on company profitability
- Use cases and configuration examples

## Future Enhancements

### Sector-Specific Revenue Rates

Instead of global `revenue_rate`, use per-sector rates:

```python
sector_revenue_rates = {
    0: 0.6,  # Agriculture (low margin)
    1: 0.8,  # Energy (moderate)
    2: 1.0,  # Manufacturing (standard)
    3: 2.0,  # Technology (high margin)
    4: 1.8,  # Finance (high margin)
    # ...
}
```

### Dynamic Revenue Rates

Revenue rate could vary based on:

- Market conditions (supply/demand)
- Competition (more firms → lower margins)
- Company size (economies of scale)
- Time (business cycles)

### Progressive Margins

Revenue rate could increase with orders:

```python
def get_revenue_rate(self, num_orders):
    # Bulk discount effect
    base_rate = 1.0
    bonus = min(num_orders * 0.01, 0.5)  # Up to 50% bonus
    return base_rate + bonus
```

---

## 7. Death Threshold System

### Overview

The `death_threshold` hyperparameter implements a bankruptcy mechanism where companies are removed from the simulation if their capital falls below a specified threshold. This creates realistic economic dynamics with company failure and natural selection.

## Mathematical Model

### Death Condition

```
if company.capital < death_threshold:
    remove company from simulation
```

Where:

- **death_threshold** = Minimum capital for survival (hyperparameter, default: 0.0)
- **company.capital** = Current company capital after profit/loss

### Economic Interpretation

| Death Threshold | Meaning | Survival Pressure |
|-----------------|---------|-------------------|
| **0.0** | No bankruptcy | None - companies continue with negative capital |
| **< 10,000** | Minimal pressure | Very weak companies eliminated |
| **5,000 - 10,000** | Moderate pressure | Realistic business environment |
| **20,000 - 50,000** | High pressure | Only profitable companies survive |
| **≥ initial_capital** | Extreme pressure | Must maintain or grow initial capital |

## Implementation

### Environment Step Process

```python
def step(self, action):
    # ... execute actions ...
    
    # Companies execute their operations
    for company in self.companies:
        profit = company.step()
        # Capital updated: capital += profit
    
    # Death check - remove bankrupt companies
    num_deaths = 0
    companies_to_remove = []
    
    for company in self.companies:
        if company.capital < self.death_threshold:
            companies_to_remove.append(company)
            num_deaths += 1
    
    for company in companies_to_remove:
        self.companies.remove(company)
        self.num_firms -= 1
    
    # Return info including deaths
    info = {
        "num_deaths": num_deaths,
        "num_firms": self.num_firms,
        # ...
    }
```

### Timing

The death check occurs **after** all companies complete their step:

1. Supply chain trades execute
2. Companies calculate costs and revenues
3. Capital is updated: `capital += (revenue - costs)`
4. **Death check runs**
5. Observation returned to agent

This ensures companies have a chance to recover through revenue before being removed.

## Use Cases

### 1. No Deaths (Baseline Study)

```python
env = IndustryEnv(death_threshold=0.0)  # Default
```

**Effect**:

- Companies never die
- Can have negative capital indefinitely
- Full dynamics observable

**When to use**:

- Studying long-term patterns
- Ablation studies
- Avoiding environment instability

### 2. Realistic Business Environment

```python
env = IndustryEnv(death_threshold=5000.0)
```

**Effect**:

- Weak companies fail
- Natural turnover
- Realistic bankruptcy rate

**When to use**:

- Production training
- Realistic economic simulation
- Studying market dynamics

### 3. Harsh Economic Conditions

```python
env = IndustryEnv(death_threshold=50000.0)
```

**Effect**:

- High failure rate
- Only strong companies survive
- Intense competition

**When to use**:

- Challenging RL tasks
- Studying resilience
- Extreme scenario testing

### 4. Must Maintain Initial Capital

```python
config = load_config("config.json")
env = IndustryEnv(
    death_threshold=config.company.initial_capital_min  # e.g., 10000
)
```

**Effect**:

- Companies must not lose initial investment
- Moderate but meaningful pressure
- Balanced realism

## Strategic Implications

### For RL Agents

**With death_threshold = 0** (no deaths):

- Can take high risks
- Exploration less constrained
- Learns full state dynamics
- May learn unrealistic strategies

**With death_threshold > 0** (with deaths):

- Must manage risk
- Location choices critical (logistic costs)
- Investment decisions matter
- Learns sustainable strategies
- More realistic behavior

### Interaction with Other Parameters

The death threshold interacts with other hyperparameters:

| Parameter Combination | Effect | Company Deaths |
|----------------------|--------|----------------|
| High `logistic_cost_rate` + High `death_threshold` | Extreme pressure | Very high |
| Low `revenue_rate` + High `death_threshold` | Low margins, high bar | High |
| High `op_cost_rate` + High `death_threshold` | Expensive operations | High |
| Low `logistic_cost_rate` + Low `death_threshold` | Easy survival | Low |

**Example - Harsh Environment**:

```python
env = IndustryEnv(
    death_threshold=20000.0,      # High bar
    logistic_cost_rate=500.0,     # Expensive transport
    revenue_rate=0.8,              # Low margins
    op_cost_rate=0.08              # High operating costs
)
# Result: Only well-placed, efficient companies survive
```

**Example - Easy Environment**:

```python
env = IndustryEnv(
    death_threshold=1000.0,        # Low bar
    logistic_cost_rate=10.0,       # Cheap transport
    revenue_rate=2.0,              # High margins
    op_cost_rate=0.02              # Low operating costs
)
# Result: Most companies survive easily
```

## Observed Patterns

From testing with `death_threshold=10000.0` and `logistic_cost_rate=500.0`:

**Early Steps (1-10)**:

- Few deaths (0-2 per step)
- Companies still have initial capital buffer
- Failures are poorly located companies

**Mid Steps (10-30)**:

- Steady deaths (1-2 per step)
- Weak companies eliminated
- Natural selection at work

**Late Steps (30+)**:

- Fewer deaths
- Survivors are strong, well-positioned
- Stable equilibrium reached

**Survival Characteristics**:

- Well-located (near supply chain partners)
- Good capital management
- Efficient operations

## Configuration

### In config.json

```json
{
  "company": {
    "op_cost_rate": 0.05,
    "initial_capital_min": 10000.0,
    "initial_capital_max": 100000.0,
    "death_threshold": 5000.0      // ← Adjust this
  }
}
```

### In Code

```python
from config import load_config

config = load_config("config.json")
env = IndustryEnv(
    death_threshold=config.company.death_threshold
)
```

## Monitoring Deaths

Track company deaths during training:

```python
total_deaths = 0
death_history = []

for episode in range(num_episodes):
    obs, _ = env.reset()
    episode_deaths = 0
    
    for step in range(max_steps):
        action = agent.act(obs)
        obs, reward, done, truncated, info = env.step(action)
        
        episode_deaths += info.get('num_deaths', 0)
        
        if done or truncated:
            break
    
    total_deaths += episode_deaths
    death_history.append(episode_deaths)
    print(f"Episode {episode}: {episode_deaths} deaths")

print(f"Average deaths per episode: {total_deaths/num_episodes:.2f}")
```

## Testing

Run comprehensive tests:

```bash
python test_death_threshold.py
```

Demonstrates:

- No threshold (0.0): No deaths
- Moderate threshold (5000.0): Realistic deaths
- High threshold (50000.0): Many deaths
- Verification of death mechanism

Visual demonstration:

```bash
python demo_death_threshold.py
```

Shows:

- 50-step simulation with deaths
- Death statistics and patterns
- Survival analysis
- Configuration recommendations

## Recommendations

### By Use Case

**Research/Ablation**:

- `death_threshold = 0.0` (no interference)

**Training Production Agents**:

- `death_threshold = 5000.0 - 10000.0` (realistic)

**Challenging Tasks**:

- `death_threshold = 20000.0 - 50000.0` (difficult)

**Extreme Scenarios**:

- `death_threshold = initial_capital_max` (only best survive)

### By Training Stage

**Early Training** (exploration):

- Low or zero threshold
- Allow agent to explore freely

**Mid Training** (refinement):

- Moderate threshold
- Start eliminating bad strategies

**Late Training** (polish):

- High threshold
- Force optimal behavior

### With Other Features

Combine strategically:

```python
# Location-focused training
env = IndustryEnv(
    death_threshold=10000.0,
    logistic_cost_rate=500.0  # Location critical
)

# Margin-focused training
env = IndustryEnv(
    death_threshold=10000.0,
    revenue_rate=0.5  # Must optimize efficiency
)

# Balanced training
env = IndustryEnv(
    death_threshold=5000.0,
    logistic_cost_rate=100.0,
    revenue_rate=1.0
)
```

---

## 8. Configuration System

### Overview

JSON-based hyperparameter management system for easy experimentation and reproducibility.

## Files

- **`config.json`**: Main configuration file
- **`config.py`**: Python loader module
- **`example_config.py`**: Usage examples

## Structure

### Environment Section

```json
"environment": {
  "size": 100.0,              // Map size (coordinate range)
  "max_company": 1000,         // Maximum companies
  "num_sectors": 7,            // Industry sectors (automotive supply chain)
  "logistic_cost_rate": 100.0, // Distance cost parameter
  "initial_firms": 10,         // Starting companies
  "max_episode_steps": 1000    // Episode length
}
```

### Company Section

```json
"company": {
  "op_cost_rate": 0.05,           // Operating cost rate (5%)
  "initial_capital_min": 10000.0,  // Min initial capital
  "initial_capital_max": 100000.0, // Max initial capital
  "investment_min": 0.0,           // Min investment
  "investment_max": 1000000.0,     // Max investment
  "new_company_capital_min": 1000.0,
  "new_company_capital_max": 1000000.0
}
```

**Note on Sector Cost Multipliers**: Sector-specific operating cost multipliers are **hardcoded in `env/sector.py`** as fundamental sector properties, not configurable parameters. Each `Sector` object has an `operating_cost_multiplier` attribute:

- **Raw Materials (1.5x)**: Highest costs due to extraction, sourcing, and commodity price volatility
- **Parts (1.2x)**: Moderate costs from manufacturing tooling and quality control
- **Electronics (1.1x)**: Precision manufacturing with clean room requirements
- **Battery/Motor (1.1x)**: Specialized materials and safety requirements
- **OEM (1.0x)**: Baseline assembly operations
- **Service (0.8x)**: Lowest costs, primarily labor-focused with minimal inventory
- **Other (1.0x)**: Baseline for miscellaneous sectors

These multipliers are applied automatically in the `Company.__init__()` method: `self.op_cost_rate = op_cost_rate * sector_relations[sector_id].operating_cost_multiplier`

To modify sector cost multipliers, edit the `sector_relations` list in `env/sector.py`.

### Training Section

```json
"training": {
  "framework": "sb3",         // RL framework
  "algorithm": "ppo",         // Algorithm
  "total_timesteps": 100000,  // Training duration
  "num_envs": 4,              // Parallel environments
  "learning_rate": 0.0003,    // Learning rate
  "batch_size": 64,           // Batch size
  "gamma": 0.99,              // Discount factor
  "gae_lambda": 0.95,         // GAE lambda
  "clip_range": 0.2,          // PPO clipping
  "n_steps": 2048,            // Steps per update
  "n_epochs": 10,             // PPO epochs
  "seed": 42,                 // Random seed
  "verbose": 1                // Verbosity
}
```

### Checkpointing Section

```json
"checkpointing": {
  "log_dir": "./logs",
  "checkpoint_dir": "./checkpoints",
  "save_freq": 10000,
  "eval_freq": 5000,
  "visualize_freq": 10000,
  "n_eval_episodes": 10,
  "save_best_model": true
}
```

### Reward Section

```json
"reward": {
  "investment_multiplier": 0.01,
  "creation_reward": 50.0,
  "invalid_action_penalty": -20.0,
  "invalid_firm_penalty": -10.0,
  "profit_multiplier": 0.001
}
```

### Supply Chain Section

```json
"supply_chain": {
  "trade_volume_fraction": 0.01,
  "revenue_rate": 1.0,
  "enable_supply_chain": true,
  "min_distance_epsilon": 0.1
}
```

**Parameters**:

- `trade_volume_fraction`: Fraction of capital used for trade (0.01 = 1%)
- `revenue_rate`: Multiplier converting orders to revenue (formula: `revenue = revenue_rate × order_amount`)
- `enable_supply_chain`: Enable/disable supply chain simulation
- `min_distance_epsilon`: Minimum distance to avoid division by zero

### Visualization Section

```json
"visualization": {
  "figsize_width": 12,
  "figsize_height": 8,
  "dpi": 150,
  "show_plots": false,
  "save_plots": true,
  "plot_format": "png"
}
```

### Ablation Section

```json
"ablation": {
  "disable_logistic_costs": false,
  "disable_supply_chain": false,
  "fixed_locations": false,
  "allow_negative_capital": false
}
```

## Usage

### Loading Configuration

```python
from config import load_config

# Load default config
config = load_config("config.json")

# Print summary
config.print_summary()

# Access parameters
rate = config.environment.logistic_cost_rate
timesteps = config.training.total_timesteps
```

### Creating Environment

```python
from env import IndustryEnv

env = IndustryEnv(
    size=config.environment.size,
    max_company=config.environment.max_company,
    num_sectors=config.environment.num_sectors,
    logistic_cost_rate=config.environment.logistic_cost_rate
)

obs, info = env.reset(options={
    "initial_firms": config.environment.initial_firms
})
```

### Modifying and Saving

```python
# Load base config
config = load_config("config.json")

# Modify parameters
config.environment.logistic_cost_rate = 500.0
config.training.total_timesteps = 500000

# Save to new file
config.to_json("config_custom.json")
```

### Training with Config

```bash
# Use default config
python main.py

# Use custom config
python main.py --config config_custom.json
```

## Pre-Configured Scenarios

Created automatically by `example_config.py`:

1. **`config_high_cost.json`**: High logistic costs (1000.0)
2. **`config_fast_training.json`**: Quick training (50k steps, 8 envs)
3. **`config_ablation.json`**: No logistic costs (baseline)

## Hyperparameter Recommendations

### Learning Rate

| Value | Effect | When to Use |
|-------|--------|-------------|
| 0.0001 | Slow, stable | Long training, stability |
| 0.0003 | **Default** | General purpose |
| 0.001 | Fast, unstable | Quick experiments |

### Number of Environments

| Value | Speed | Memory | When to Use |
|-------|-------|--------|-------------|
| 1 | Slowest | Lowest | Debugging |
| 4 | **Default** | Moderate | Standard |
| 8 | Fast | High | Production |
| 16 | Fastest | Highest | GPU available |

### Logistic Cost Rate

| Value | Clustering | When to Use |
|-------|-----------|-------------|
| 0 | None | Ablation baseline |
| 10 | Weak | Testing |
| 100 | **Default** | Balanced |
| 500 | Strong | Strategic focus |
| 1000+ | Forced | Extreme scenarios |

---

## 10. Training Guide

### Frameworks Supported

The environment supports 3 RL frameworks:

### 1. Stable-Baselines3 (Recommended)

**Pros**: Easy to use, well-documented, mature
**Cons**: CPU-focused, limited scalability

```bash
python main.py --framework sb3 --algorithm ppo --timesteps 100000
```

Algorithms available:

- **PPO** (default): Robust, general-purpose
- **A2C**: Faster, simpler, less stable
- **SAC**: For continuous control (experimental)

### 2. Ray RLlib

**Pros**: Highly scalable, distributed training
**Cons**: More complex setup

```bash
python main.py --framework rllib --algorithm ppo --timesteps 100000
```

### 3. Custom Loop

**Pros**: Educational, full control
**Cons**: Basic implementation, slower

```bash
python main.py --framework custom --timesteps 10000
```

## Training Workflow

### 1. Quick Test

```bash
# Fast sanity check (2-3 minutes)
python main.py --framework custom --timesteps 10000 --initial-firms 5
```

### 2. Standard Training

```bash
# Default training (10-15 minutes)
python main.py --framework sb3 --algorithm ppo --timesteps 100000
```

### 3. Production Training

```bash
# Long training for best results (1-2 hours)
python main.py --framework sb3 --algorithm ppo \
  --timesteps 500000 \
  --num-envs 8 \
  --save-freq 20000 \
  --eval-freq 10000
```

### 4. Hyperparameter Sweep

```bash
# Test different logistic cost rates
for rate in 10 100 500 1000; do
  python main.py --logistic-cost-rate $rate --timesteps 200000
done
```

### 5. Ablation Study

```bash
# Train baseline (no logistics)
python main.py --config config_ablation.json

# Train with logistics
python main.py --config config.json

# Compare in TensorBoard
tensorboard --logdir=./logs
```

## Monitoring Training

### TensorBoard

```bash
tensorboard --logdir=./logs
```

Metrics available:

- **Episode rewards**: Total reward per episode
- **Episode lengths**: Steps per episode
- **Policy loss**: Actor loss
- **Value loss**: Critic loss
- **Entropy**: Policy exploration
- **Custom metrics**: Profit, logistic costs, firm counts

### Console Output

Training displays:

```
Episode 10/100 - Avg Reward: 1234.56 - Steps: 500 - Firms: 50
Training completed! Time: 10.5 minutes
```

### Checkpoints

Saved automatically:

- **Periodic**: Every `save_freq` steps (default: 10000)
- **Best model**: Highest evaluation reward
- **Final**: At end of training

## Evaluation

### Evaluate Trained Model

```bash
python main.py --mode eval \
  --model-path ./checkpoints/sb3_ppo_*/ppo_final.zip \
  --framework sb3
```

Output:

- Average reward over evaluation episodes
- Standard deviation
- Episode statistics
- Final visualization dashboard

### Demo Mode

```bash
python main.py --mode demo \
  --model-path ./checkpoints/sb3_ppo_*/best_model.zip \
  --framework sb3
```

Shows:

- Step-by-step visualization
- Action decisions
- Company locations
- Performance metrics

## Troubleshooting

### Low Rewards

**Symptoms**: Rewards not improving, staying negative

**Solutions**:

1. Increase training time: `--timesteps 500000`
2. Adjust learning rate: `--lr 0.001`
3. More exploration: Increase entropy coefficient
4. Check reward function: Verify positive rewards possible

### Training Instability

**Symptoms**: Rewards oscillating wildly

**Solutions**:

1. Decrease learning rate: `--lr 0.0001`
2. Increase batch size: `--batch-size 128`
3. Use gradient clipping (already default)
4. Normalize observations/rewards (in config advanced section)

### Slow Training

**Symptoms**: Taking too long per step

**Solutions**:

1. Increase parallel envs: `--num-envs 8`
2. Decrease initial firms: `--initial-firms 5`
3. Use custom framework for testing
4. Check if logistic costs expensive (try lower rate)

### Out of Memory

**Symptoms**: Crashes with memory errors

**Solutions**:

1. Decrease `num_envs`: `--num-envs 2`
2. Decrease `max_company`: `--max-company 500`
3. Reduce batch size: `--batch-size 32`
4. Use smaller models (edit main.py)

## Performance Optimization

### Training Speed

| Configuration | Speedup | Requirements |
|---------------|---------|--------------|
| Baseline (1 env, CPU) | 1x | Minimal |
| 4 envs, CPU | ~3x | 4+ CPU cores |
| 8 envs, CPU | ~5x | 8+ CPU cores |
| 16 envs, GPU | ~8x | GPU, CUDA |

### Recommendations

**For CPU**:

- Use 4-8 parallel environments
- PPO with default hyperparameters
- Stable-Baselines3 framework

**For GPU**:

- Use 16+ parallel environments
- Consider Ray RLlib for distributed
- Tune batch sizes larger

**For Quick Tests**:

- Use custom framework
- 1-2 environments
- 10k-50k timesteps

---

## 11. Visualization System

### Overview

Comprehensive matplotlib-based visualization inspired by coord.py, featuring interactive plots with hover information, environment persistence, and automatic periodic visualization at 600 DPI.

## Visualization Types

### 1. Company Locations Plot

Shows all companies on spatial map:

```python
from visualize import plot_companies

plot_companies(env.companies, title="Company Locations")
```

**Features**:

- Color-coded by sector
- Size proportional to √capital
- Interactive hover showing company details
- Sector legend

**Use for**: Understanding spatial distribution

### 2. Sector Distribution

Bar chart of companies per sector:

```python
from visualize import plot_sector_distribution

plot_sector_distribution(env.companies)
```

**Features**:

- Count per sector
- Color-coded bars
- Percentage labels

**Use for**: Analyzing sector balance

### 3. Capital Distribution Heatmap

2D heatmap of capital density:

```python
from visualize import plot_capital_distribution

plot_capital_distribution(env.companies, grid_size=20)
```

**Features**:

- Spatial capital concentration
- Hotspot identification
- Colormap visualization

**Use for**: Finding economic centers

### 4. Sector Clusters

Multi-panel view of each sector:

```python
from visualize import plot_sector_clusters

plot_sector_clusters(env.companies)
```

**Features**:

- Separate subplot per sector
- Spatial clustering visible
- Company counts per sector

**Use for**: Sector-specific analysis

### 5. Network Connections

Shows proximity relationships:

```python
from visualize import plot_network_connections

plot_network_connections(env.companies, max_distance=30.0)
```

**Features**:

- Lines between nearby companies
- Connection strength by distance
- Network topology visualization

**Use for**: Understanding supply chain potential

### 6. Comprehensive Dashboard

All-in-one view:

```python
from visualize import create_dashboard

create_dashboard(env.companies, save_path="dashboard.png")
```

**Features**:

- 4 panels: locations, sectors, capital, clusters
- Complete overview
- Saves to file

**Use for**: Reports, presentations, monitoring

## Environment Persistence

### Save and Load Complete Simulation State

The environment supports saving/loading complete simulation states for analysis and resumption:

```python
from env import IndustryEnv, load_environment, visualize_saved_environment

# Create and run environment
env = IndustryEnv(config.environment)
obs, info = env.reset(options={"initial_firms": 20})

# Run simulation
for step in range(1000):
    obs, reward, terminated, truncated, info = env.step(action)

# Save complete environment state
filepath = env.save_environment()  # Returns: environment_20241015_143022.pkl
# Or with custom filename
env.save_environment("checkpoints/milestone_1000.pkl")

# Later: Load saved environment
loaded_env = load_environment("environment_20241015_143022.pkl")
print(f"Loaded {loaded_env.num_firms} firms at step {loaded_env.current_step}")

# Visualize saved state with interactive plot
visualize_saved_environment("environment_20241015_143022.pkl", output_dir="analysis")
```

**Saved State Includes:**

- All company objects with complete state (capital, location, sector, revenue, etc.)
- Current step counter
- Environment configuration
- Spatial parameters
- Timestamp

### Automatic Periodic Visualization

Configure automatic visualization during training:

```python
# In config.json
{
  "visualization": {
    "visualize_every_n_steps": 100,  # 0 = disable, >0 = visualize every N steps
    "visualization_dir": "visualizations",
    "dpi": 600,  # High-resolution output (default: 600, was 150)
    "save_plots": true,
    "show_plots": false
  }
}

# Environment automatically creates PNG files every 100 steps:
# visualizations/step_000100.png
# visualizations/step_000200.png
# ...
```

**Output:** Publication-quality PNG files at 600 DPI (~1.0 MB each) with improved layout spacing.

### Manual Visualization Control

```python
# Visualize at specific checkpoints
env.visualize_step("milestone_500")     # Creates: step_milestone_500.png
env.visualize_step("before_policy_change")
env.visualize_step()                     # Uses current step number
```

### Layout Improvements

Dashboard visualizations feature improved spacing and alignment:

- **Higher DPI**: 600 (4x resolution increase from 150)
- **Better spacing**: `hspace=0.35`, `wspace=0.25` with explicit margins
- **Larger figures**: 18×12 inches (was 16×12)
- **Proper positioning**: Title at y=0.98, no overlapping subplots
- **Professional quality**: Publication-ready output

## Interactive Features

### Hover Information

Using mplcursors (inspired by coord.py):

```python
import mplcursors

scatter = ax.scatter(x, y, ...)
cursor = mplcursors.cursor(scatter, hover=True)

@cursor.connect("add")
def on_add(sel):
    sel.annotation.set_text(f"Company {sel.index}\nCapital: ${capital}")
```

**Shows**:

- Company ID
- Capital amount
- Sector name
- Location coordinates
- Revenue, costs

### Zoom and Pan

All plots support:

- Mouse wheel zoom
- Click-drag pan
- Reset view button

## Configuration

### Plot Settings

In `config.json`:

```json
"visualization": {
  "figsize_width": 12,
  "figsize_height": 8,
  "dpi": 150,
  "show_plots": false,
  "save_plots": true,
  "plot_format": "png"
}
```

### Color Schemes

Sector colors defined in `visualize.py`:

```python
SECTOR_COLORS = [
    '#FF6B6B',  # Agriculture (red)
    '#4ECDC4',  # Energy (cyan)
    '#45B7D1',  # Manufacturing (blue)
    '#96CEB4',  # Technology (green)
    '#FFEAA7',  # Finance (yellow)
    '#DFE6E9',  # Healthcare (gray)
    '#74B9FF',  # Retail (light blue)
    '#A29BFE',  # Transportation (purple)
    '#FD79A8',  # Construction (pink)
    '#FDCB6E',  # Services (orange)
]
```

## Examples

### During Training

Automatically saved every `visualize_freq` steps (default: 10000):

```
./logs/sb3_ppo_20251014_120000/
├── dashboard_episode_10.png
├── dashboard_episode_20.png
└── dashboard_episode_30.png
```

### After Training

Create custom visualizations:

```python
from env import IndustryEnv
from visualize import *

env = IndustryEnv()
obs, _ = env.reset(options={"initial_firms": 20})

# Run simulation
for _ in range(100):
    action = env.action_space.sample()
    obs, reward, done, truncated, info = env.step(action)

# Visualize results
plot_companies(env.companies)
plot_sector_clusters(env.companies)
create_dashboard(env.companies, save_path="final_state.png")
```

### Animation (Manual)

Create frames for animation:

```python
for i in range(100):
    env.step(action)
    if i % 10 == 0:
        create_dashboard(env.companies, save_path=f"frame_{i:03d}.png")

# Use external tool to create video
# ffmpeg -framerate 10 -i frame_%03d.png -c:v libx264 animation.mp4
```

## Best Practices

1. **Use dashboards** for overview, specific plots for detail
2. **Save plots** during training for later analysis
3. **Interactive mode** (`show_plots=true`) for exploration
4. **Batch mode** (`show_plots=false`) for automated training
5. **High DPI** (150-300) for publication-quality figures

---

## 12. Spatial Analysis

### Overview

The `utils/spatial_utils.py` module provides utilities for analyzing spatial patterns and relationships between companies.

## Functions

### Find Nearest Companies

```python
from spatial_utils import find_nearest_companies

nearest = find_nearest_companies(company, env.companies, n=5)

for other, distance in nearest:
    print(f"Company at ({other.x}, {other.y}): {distance:.2f} units away")
```

**Use for**: Finding nearby competitors or partners

### Find Companies in Radius

```python
from spatial_utils import find_companies_in_radius

nearby = find_companies_in_radius(
    center=(50.0, 50.0),
    companies=env.companies,
    radius=20.0
)

print(f"Found {len(nearby)} companies within 20 units")
```

**Use for**: Regional analysis, market definition

### Calculate Sector Clustering

```python
from spatial_utils import calculate_sector_clustering

clustering = calculate_sector_clustering(env.companies)

for sector_id, metrics in clustering.items():
    print(f"Sector {sector_id}:")
    print(f"  Mean nearest distance: {metrics['mean_distance']:.2f}")
    print(f"  Clustering coefficient: {metrics['clustering_coef']:.2f}")
```

**Use for**: Measuring agglomeration, industrial districts

### Suggest Optimal Location

```python
from spatial_utils import suggest_optimal_location

# Suggest location to cluster with sector
location = suggest_optimal_location(
    companies=env.companies,
    sector_id=2,
    strategy="cluster"
)

print(f"Optimal location: ({location[0]:.2f}, {location[1]:.2f})")
```

Strategies:

- **"cluster"**: Near existing companies in same sector
- **"disperse"**: Away from all companies
- **"supply_chain"**: Near suppliers/customers

**Use for**: Guiding agent actions, evaluating decisions

### ASCII Visualization

```python
from spatial_utils import visualize_locations_ascii

visualize_locations_ascii(env.companies, grid_size=20)
```

Output:

```
    0   5  10  15  20
  +----+----+----+----+
0 |    |  A |    |    |
  +----+----+----+----+
5 | M  |    |  T |    |
  +----+----+----+----+
10|    | F  |    |  M |
  +----+----+----+----+
```

**Use for**: Quick terminal visualization, debugging

## Example Analysis Script

```python
from env import IndustryEnv
from spatial_utils import *

env = IndustryEnv()
obs, _ = env.reset(options={"initial_firms": 20})

# Run simulation
for _ in range(100):
    action = env.action_space.sample()
    env.step(action)

# Analyze spatial patterns
print("=== SPATIAL ANALYSIS ===\n")

# 1. Overall distribution
print("ASCII Map:")
visualize_locations_ascii(env.companies)

# 2. Sector clustering
print("\nSector Clustering:")
clustering = calculate_sector_clustering(env.companies)
for sector_id, metrics in clustering.items():
    print(f"  Sector {sector_id}: {metrics['clustering_coef']:.2f}")

# 3. Company-specific analysis
if env.companies:
    company = env.companies[0]
    print(f"\nAnalyzing Company 0 at ({company.x:.1f}, {company.y:.1f}):")
    
    nearest = find_nearest_companies(company, env.companies, n=3)
    print("  Nearest neighbors:")
    for other, dist in nearest:
        print(f"    Sector {other.sector_id} at distance {dist:.2f}")
    
    # Optimal location for new company
    optimal = suggest_optimal_location(env.companies, sector_id=2)
    print(f"\n  Optimal location for Manufacturing: ({optimal[0]:.1f}, {optimal[1]:.1f})")
```

## Integration with RL

### Observation Augmentation (Future)

```python
# Could add spatial features to observations
def get_spatial_features(self, company_id):
    company = self.companies[company_id]
    nearest = find_nearest_companies(company, self.companies, n=5)
    clustering = calculate_sector_clustering(self.companies)
    
    return {
        "nearest_distance": nearest[0][1] if nearest else 0.0,
        "sector_clustering": clustering[company.sector_id]['clustering_coef'],
        # ...
    }
```

### Reward Shaping

```python
# Bonus for good locations
location_bonus = 0.0
if new_company_created:
    nearby_same_sector = find_companies_in_radius(
        location, companies, radius=10.0, sector_filter=sector_id
    )
    location_bonus = len(nearby_same_sector) * 5.0  # Encourage clustering

reward += location_bonus
```

### Action Guidance

```python
# Suggest location if creating company
if action["op"] == 1:  # Create
    suggested = suggest_optimal_location(
        self.companies,
        sector_id=action["create"]["sector"],
        strategy="cluster"
    )
    # Could guide exploration towards suggested location
```

---

## 13. API Reference

### Environment Class

```python
class IndustryEnv(gym.Env)
```

### Constructor

```python
__init__(
    size: float = 100.0,
    max_company: int = 1000,
    num_sectors: int = 7,
    logistic_cost_rate: float = 100.0
)
```

**Parameters**:

- `size`: Map dimensions (0 to size for both x and y)
- `max_company`: Maximum number of companies allowed
- `num_sectors`: Number of industry sectors (default: 7, automotive supply chain)
- `logistic_cost_rate`: Hyperparameter for logistic costs

### Methods

#### `reset(seed=None, options=None) -> (obs, info)`

Reset environment to initial state.

**Parameters**:

- `seed`: Random seed (optional)
- `options`: Dict with optional keys:
  - `"initial_firms"`: Number of companies to create (default: 0)

**Returns**:

- `obs`: Initial observation
- `info`: Empty dict

#### `step(action) -> (obs, reward, terminated, truncated, info)`

Execute one environment step.

**Parameters**:

- `action`: Dict with keys:
  - `"op"`: 0 (invest) or 1 (create)
  - `"invest"`: Dict with `"firm_id"` and `"amount"`
  - `"create"`: Dict with `"initial_capital"`, `"sector"`, `"location"`

**Returns**:

- `obs`: New observation
- `reward`: Scalar reward
- `terminated`: Always False
- `truncated`: True if max steps reached
- `info`: Dict with:
  - `"total_profit"`: Sum of all company profits
  - `"total_logistic_cost"`: Sum of logistic costs
  - `"num_firms"`: Current company count
  - `"action_type"`: "invest" or "create"

### Properties

- `action_space`: Gymnasium Dict space
- `observation_space`: Gymnasium Dict space
- `companies`: List of Company objects
- `num_firms`: Current number of companies
- `current_step`: Current step count

## Company Class

```python
class Company
```

### Constructor

```python
__init__(
    capital: float,
    sector_id: int,
    location: Tuple[float, float],
    op_cost_rate: float = 0.05,
    logistic_cost_rate: float = 100.0
)
```

### Attributes

- `capital`: Current capital amount
- `sector_id`: Industry sector (0-9)
- `location`: (x, y) coordinates
- `op_cost_rate`: Operating cost rate
- `logistic_cost_rate`: Logistic cost parameter
- `revenue`: Current revenue (reset each step)
- `logistic_cost`: Current logistic cost (reset each step)
- `orders`: Number of orders received

### Methods

#### `distance_to(other: Company) -> float`

Calculate Euclidean distance to another company.

#### `calculate_logistic_cost_to(other: Company, trade_volume: float = 1.0) -> float`

Calculate logistic cost for trading with another company.

#### `step() -> float`

Execute one time step, returns profit.

#### `invest(amount: float)`

Add capital investment.

#### `add_revenue(amount: float)`

Add revenue from trades.

#### `add_logistic_cost(cost: float)`

Add logistic cost.

### Properties

- `x`: X-coordinate
- `y`: Y-coordinate

## Configuration Classes

### Config

Main configuration container:

```python
config = Config.from_json("config.json")
config.environment.logistic_cost_rate
config.training.total_timesteps
config.to_json("output.json")
config.print_summary()
```

### Sub-configs

- `EnvironmentConfig`
- `CompanyConfig`
- `TrainingConfig`
- `CheckpointingConfig`
- `RewardConfig`
- `SupplyChainConfig`
- `VisualizationConfig`
- `AdvancedConfig`
- `AblationConfig`
- `ExperimentalConfig`

## Visualization Functions

All in `visualize.py`:

```python
plot_companies(companies, title="", figsize=(12, 8), show=True)
plot_sector_distribution(companies, figsize=(10, 6), show=True)
plot_capital_distribution(companies, grid_size=20, figsize=(10, 8), show=True)
plot_sector_clusters(companies, figsize=(15, 10), show=True)
plot_network_connections(companies, max_distance=30.0, figsize=(12, 8), show=True)
create_dashboard(companies, figsize=(16, 12), save_path=None, show=True)
```

## Spatial Utility Functions

All in `spatial_utils.py`:

```python
find_nearest_companies(company, companies, n=5) -> List[Tuple[Company, float]]
find_companies_in_radius(center, companies, radius, sector_filter=None) -> List[Company]
calculate_sector_clustering(companies) -> Dict[int, Dict]
suggest_optimal_location(companies, sector_id, strategy="cluster", map_size=100.0) -> Tuple[float, float]
visualize_locations_ascii(companies, grid_size=20, map_size=100.0)
```

---

## 9. Module Structure

### Overview

The codebase is organized into Python packages for better maintainability and clarity. The structure has been reorganized from flat files into proper package hierarchy with `env/`, `utils/`, and `config/` packages.

```
industry-sim/
├── env/                    ← Core simulation package
│   ├── __init__.py
│   ├── env.py             ← IndustryEnv (Gymnasium interface)
│   ├── company.py         ← Company class with products & supply chain
│   └── sector.py          ← Sector definitions & tier calculation
│
├── config/                 ← Configuration package
│   ├── __init__.py
│   ├── config.py          ← Config classes (EnvironmentConfig, etc.)
│   ├── config.json        ← Default configuration
│   ├── config_modified.json
│   └── config_without_products.json
│
├── utils/                  ← Utility functions package
│   ├── __init__.py
│   ├── visualize.py       ← Plotting & dashboards (600 DPI)
│   └── spatial_utils.py   ← Spatial analysis utilities
│
├── data/                   ← Company data pipeline
│   ├── README.md          ← 783-line comprehensive data guide
│   ├── supply_chain.py    ← Data processing script
│   ├── data.xlsx          ← Source Excel data (927 companies)
│   ├── company_classification.json
│   └── company_classification.csv
│
├── demos/                  ← Example scripts
├── tests/                  ← Test suite
├── main.py                ← Training entry point
└── README.md              ← Quick start guide
```

**Package Dependencies:**

```
env.sector (no dependencies)
    ↓
env.company (depends on: env.sector, numpy)
    ↓
env.env (depends on: env.company, env.sector, gymnasium, numpy)
    ↓
config.config (depends on: env.sector, dataclasses, json)
    ↓
utils.visualize (depends on: env, matplotlib, mplcursors)
utils.spatial_utils (depends on: env.company, numpy)
```

## Module Hierarchy

### sector.py (No Dependencies)

**Contents**:

- `Sector` class: Industry sector definition
- `sector_relations`: List of 7 pre-defined sectors (automotive supply chain)
- `NUM_SECTORS`: Constant = 7
- `calculate_sector_tiers()`: Automatic tier calculation using topological sort

**Purpose**: Defines the supply chain structure

**Usage**:

```python
from sector import sector_relations, NUM_SECTORS, calculate_sector_tiers, Sector
```

### company.py (Depends on: numpy, sector.py)

**Contents**:

- `Company` class: Full company implementation with products, supply chain, and logistics
- `SECTOR_TIERS`: Dictionary mapping sector IDs to tiers (calculated from `sector_relations`)

**Purpose**: Models individual company behavior

**Usage**:

```python
from company import Company, SECTOR_TIERS
```

### env.py (Depends on: gymnasium, numpy, company.py, sector.py)

**Contents**:

- `IndustryEnv` class: Gymnasium environment that orchestrates the simulation
- Manages multiple companies
- Handles action/observation spaces
- Coordinates supply chain simulation

**Purpose**: RL environment interface

**Usage**:

```python
from env import IndustryEnv
```

### config.py (Depends on: dataclasses, json, sector.py)

**Contents**:

- `Config` class: Main configuration container
- Multiple `@dataclass` configs: `EnvironmentConfig`, `CompanyConfig`, `TrainingConfig`, etc.
- JSON loading/saving methods
- Configuration validation

**Purpose**: Centralized hyperparameter management

**Usage**:

```python
from config import Config
config = Config.from_json("config.json")
```

## Dependency Graph

```
sector.py (no dependencies)
    ↓
company.py (depends on: numpy, sector)
    ↓
env.py (depends on: gymnasium, numpy, company, sector)
    ↓
config.py (depends on: dataclasses, json, sector)

Applications:
  • tests/        → import company, env, config
  • demos/        → import company, sector, env, config
  • visualize.py  → import company, sector, env
  • spatial_utils.py → import company
  • main.py       → import env, config
```

## Import Patterns

### Use Case 1: Working with Companies

```python
from company import Company, SECTOR_TIERS

company = Company(
    capital=50000.0,
    sector_id=1,
    location=(50.0, 50.0)
)
```

### Use Case 2: Working with Sectors

```python
from sector import sector_relations, Sector, NUM_SECTORS, calculate_sector_tiers

# Access sector info
for sector in sector_relations:
    print(f"{sector.name}: Tier {SECTOR_TIERS[sector.id]}")

# Recalculate tiers (if you modify sector_relations)
new_tiers = calculate_sector_tiers(sector_relations)
```

### Use Case 3: Running Simulation

```python
from env import IndustryEnv
from config import Config

config = Config.from_json("config.json")
env = IndustryEnv(config.environment)
obs, info = env.reset()
```

### Use Case 4: Full Setup

```python
from company import Company, SECTOR_TIERS
from sector import sector_relations, NUM_SECTORS
from env import IndustryEnv
from config import Config

# Load config
config = Config.from_json("config.json")

# Create environment
env = IndustryEnv(
    size=config.environment.size,
    max_company=config.environment.max_company,
    num_sectors=NUM_SECTORS,
    logistic_cost_rate=config.environment.logistic_cost_rate
)

# Run simulation
obs, _ = env.reset(options={"initial_firms": 10})
```

## File Size Comparison

### Before Refactoring

- `env.py`: ~928 lines (included Sector + Company + IndustryEnv)

### After Refactoring

- `sector.py`: ~55 lines (Sector + sector_relations + tier calculation)
- `company.py`: ~281 lines (Company + SECTOR_TIERS)
- `env.py`: ~611 lines (IndustryEnv only)

### Benefits

- ✅ Reduced env.py size by ~317 lines (~34% reduction)
- ✅ Clear separation of concerns
- ✅ Improved maintainability
- ✅ Better reusability
- ✅ Easier testing of individual components

## Testing Strategy

Each module can be tested independently:

```bash
# Test sectors
python -c "from sector import sector_relations, calculate_sector_tiers; print('Sectors:', len(sector_relations))"

# Test company
python -c "from company import Company; c = Company(10000, 0, (50, 50)); print('Capital:', c.capital)"

# Test environment
python -c "from env import IndustryEnv; env = IndustryEnv(); print('Created')"

# Test config
python -c "from config import Config; c = Config(); print('Config loaded')"
```

## Adding New Features

### Adding a New Sector

1. Edit `sector.py`:

   ```python
   sector_relations.append(Sector(
       id=7,
       name="NewSector",
       suppliers=["Raw"],
       consumers=["Service"]
   ))
   NUM_SECTORS = 8  # Update constant (7 → 8)
   ```

2. Tiers are **automatically recalculated** via `calculate_sector_tiers()`

3. No changes needed in other files!

### Adding a New Company Attribute

1. Edit `company.py`:

   ```python
   class Company:
       def __init__(self, ...):
           # ... existing code ...
           self.new_attribute = value
   ```

2. Update environment if needed (`env.py`)

3. Update configuration if it's a hyperparameter (`config.py`)

### Adding a New Hyperparameter

1. Edit `config.py`:

   ```python
   @dataclass
   class EnvironmentConfig:
       # ... existing parameters ...
       new_parameter: float = 1.0
   ```

2. Update `config.json`:

   ```json
   {
     "environment": {
       "new_parameter": 1.0
     }
   }
   ```

3. Use in environment (`env.py` or `company.py`)

## Best Practices for Module Usage

1. **Import only what you need**: Don't import entire modules unnecessarily
2. **Use absolute imports**: `from env import IndustryEnv` not `from .env import ...`
3. **Respect dependencies**: Don't create circular dependencies
4. **Keep sector.py minimal**: It's the foundation, keep it simple
5. **Configuration first**: Load config before creating environment
6. **Test imports**: Always test that your imports work in isolation

---

## 14. Best Practices

### Environment Design

### ✅ Do

- **Use aggregate observations** for scalability
- **Test with small timesteps** first (10k-50k)
- **Monitor logistic costs** in info dict
- **Save configs** with experiment results
- **Use visualization** to understand behavior
- **Start with default hyperparameters**

### ❌ Don't

- **Don't use full company state** in observations (doesn't scale)
- **Don't train without monitoring** (use TensorBoard)
- **Don't ignore logistic costs** (major factor in rewards)
- **Don't use very high initial firms** (slow steps)
- **Don't forget to seed** for reproducibility

## Training Strategy

### Progressive Approach

1. **Quick test** (custom, 10k steps): Verify setup
2. **Short training** (sb3, 100k steps): Baseline performance
3. **Medium training** (sb3, 500k steps): Good results
4. **Long training** (sb3, 1M+ steps): Best results

### Hyperparameter Tuning

**Order of importance**:

1. **Logistic cost rate**: Biggest impact on behavior
2. **Learning rate**: Affects convergence
3. **Number of environments**: Training speed
4. **Reward multipliers**: Fine-tuning
5. **Other PPO params**: Advanced optimization

### Ablation Studies

**Recommended comparisons**:

1. With vs without logistic costs
2. Different logistic cost rates (10, 100, 500, 1000)
3. Different initial firm counts (5, 10, 20, 50)
4. Different map sizes (50, 100, 200)

## Configuration Management

### Version Control

```bash
# Keep configs in git
git add config.json config_*.json
git commit -m "Add experiment configurations"

# Tag important experiments
git tag experiment-high-logistics
```

### Naming Convention

```
config_<feature>_<value>.json
```

Examples:

- `config_logistics_500.json`
- `config_ablation_no_supply.json`
- `config_fast_debug.json`
- `config_production_1M.json`

### Documentation

Include README in config directory:

```markdown
# Experiment Configurations

- `config.json`: Default baseline
- `config_high_cost.json`: logistic_cost_rate=1000, tests strong clustering
- `config_ablation.json`: logistic_cost_rate=0, baseline without logistics
```

## Performance Optimization

### Training Speed

**To improve**:

1. Increase `num_envs` (4 → 8 → 16)
2. Use GPU if available
3. Decrease `initial_firms` (10 → 5)
4. Use simpler algorithms (A2C faster than PPO)

**To trade for accuracy**:

1. Decrease `batch_size` (faster but noisier)
2. Decrease `n_steps` (more frequent updates)
3. Use fewer evaluation episodes

### Memory Usage

**To reduce**:

1. Decrease `max_company` limit
2. Decrease `num_envs`
3. Use smaller replay buffers
4. Limit checkpoint retention

## Debugging

### Common Issues and Solutions

**No rewards**: Check reward function, verify positive outcomes possible

**Nan/Inf in training**: Lower learning rate, add gradient clipping, normalize inputs

**Slow convergence**: Increase learning rate slightly, use more environments, longer training

**Unstable training**: Decrease learning rate, increase batch size, check for bugs in reward

**Out of memory**: Reduce num_envs, reduce max_company, use smaller batches

### Debugging Tools

```python
# Add debug prints in env.step()
def step(self, action):
    print(f"Action: {action['op']}, Firms: {self.num_firms}")
    # ...
    print(f"Reward: {reward}, Profit: {info['total_profit']}")
    return obs, reward, terminated, truncated, info
```

```python
# Validate actions
def step(self, action):
    assert action["op"] in [0, 1], f"Invalid op: {action['op']}"
    if action["op"] == 0:
        assert 0 <= action["invest"]["firm_id"] < self.num_firms
    # ...
```

## Reproducibility

### Essential for Reproducibility

1. **Save config** with results
2. **Set seed** (`--seed 42`)
3. **Record versions**:

   ```python
   import gymnasium, stable_baselines3
   print(f"Gym: {gymnasium.__version__}")
   print(f"SB3: {stable_baselines3.__version__}")
   ```

4. **Document hardware** (CPU vs GPU, cores, memory)
5. **Use version control** (git)

### Results Package

For each experiment, save:

```
experiment_name/
├── config.json              # Configuration used
├── requirements.txt         # Package versions
├── training_history.json    # Episode data
├── final_model.zip          # Trained model
├── evaluation_results.txt   # Performance metrics
├── dashboard.png            # Final visualization
└── README.md               # Experiment notes
```

## Research Workflow

### 1. Hypothesis

Example: "Higher logistic costs lead to stronger company clustering"

### 2. Design Experiments

```python
experiments = [
    {"name": "baseline", "logistic_cost_rate": 0},
    {"name": "low", "logistic_cost_rate": 10},
    {"name": "medium", "logistic_cost_rate": 100},
    {"name": "high", "logistic_cost_rate": 500},
]
```

### 3. Run Experiments

```bash
for exp in "${experiments[@]}"; do
    python main.py --config config_${exp}.json --seed 42
done
```

### 4. Analyze Results

```python
# Compare metrics across experiments
for exp_dir in log_dirs:
    history = load_json(f"{exp_dir}/training_history.json")
    plot_learning_curve(history)
    
# Statistical significance
from scipy.stats import ttest_ind
t_stat, p_value = ttest_ind(rewards_baseline, rewards_high_cost)
```

### 5. Visualize

```python
# Create comparison plots
fig, axes = plt.subplots(2, 2)
for i, exp in enumerate(experiments):
    companies = load_companies(f"{exp}/final_state.pkl")
    plot_companies(companies, ax=axes.flat[i], title=exp["name"])
plt.savefig("comparison.png")
```

### 6. Document

```markdown
# Results

## Hypothesis
Higher logistic costs lead to stronger clustering.

## Methods
- 4 configurations: rate ∈ {0, 10, 100, 500}
- 3 seeds per configuration
- 500k timesteps training
- PPO algorithm

## Results
| Config | Clustering Coef | Avg Reward | p-value |
|--------|----------------|------------|---------|
| 0      | 0.12 ± 0.03   | 1234 ± 45  | -       |
| 10     | 0.24 ± 0.05   | 1189 ± 38  | 0.032   |
| 100    | 0.56 ± 0.07   | 1045 ± 52  | <0.001  |
| 500    | 0.83 ± 0.04   | 892 ± 29   | <0.001  |

## Conclusions
- Hypothesis confirmed (p < 0.001)
- Strong positive correlation (r=0.94)
- Trade-off: clustering reduces total reward
```

---

## Conclusion

This detailed documentation covers all aspects of the Industry Simulation RL Environment. For quick start and overview, see `README.md`.

**Key Takeaways**:

1. **Environment** models spatial economic dynamics with supply chains
2. **Logistic costs** create strategic location decisions (inverse square law)
3. **Configuration system** enables easy experimentation
4. **Training infrastructure** supports multiple frameworks
5. **Visualization** helps understand agent behavior
6. **Best practices** ensure reproducible research

For questions or issues, please refer to specific sections above or check the example scripts.

**Happy training!** 🚀
